# 发布订阅者模式

目标：解耦，让各个模块之间没有紧密的联系

现在的处理方法是 属性在更新的时候调用 mountComponent 方法

问题：mountComponent 更新的是什么？？？（现在）全部的页面 ->当前虚拟 DOM 对应的页面 DOM

在 vue 中，整个的更新都是按照组件为单位进行 **_判断_**，以节点为单位进行提交

- 如果代码中没有自定义组件，那么在比较算法的时候，我们会将全部的模板对应的虚拟 DOM 进行比较

- 如果代码中含有自定义组件，那么在比较算法的时候，就会判断更新的是哪一些组件中的属性，只会判断更新数据的组件，其他组件不会更新

复制的页面是有很多组件构成，每一个属性要更新的都要调用更新的方法？

**目标，如果修改了什么属性，就尽可能只更新这些属性对应的页面 DOM**

这样就一定不能将更新的代码写死

实际上就是事件模型（事件模型详情见 day02\demes\09-事件模型.html）

1. 有个 event 对象
2. on,off,emit 方法

实现事件模型，思考怎么用？

1. event 是一个全局对象
2. event.on('事件名'，处理函数)， 订阅事件
   1. 事件可以连续订阅
   2. 可以移除：event.off()
      1. 移除所有
      2. 移除某一个类型的事件
      3. 移除某一个类型的某一个处理函数
3. 写别的代码
4. event.emit('事件名'，参数)， 先前注册的事件处理函数就会依次调用

原因：

1. 描述发布订阅模式
2. 后面会使用到事件

发布订阅者模式（形式不局限于函数，形式可以是对象等）：

1. 中间的全局的容器，用来**存储**可以被触发的东西（函数，对象）
2. 需要有一个方法，可以往容器中**传入**东西（函数，对象）
3. 需要有一个方法，可以将容器中的东西取出来**使用**（函数使用，对象的方法调用）

Vue 模型

页面中的变更（diff）是一组件为单位

- 但是如果页面中有多个组件（多 watcher 的一种情况），第一次会有多个组件的 watcher 存入到全网 watcher 中
- 如果修改了局部的数据（例如其中一个组件的数据）
- 表示只会对该组件进行 diff 算法，也就是说只会重新 render 生成该组件的 VNode（不会重新生成抽象语法树）
- 只会访问该组件的 watcher
- 也就表示再次往全局存储的只有该组件的 watcher
- 页面更新的时候也就只需要更新一部分
