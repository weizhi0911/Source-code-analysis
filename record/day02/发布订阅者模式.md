# 发布订阅者模式

目标：解耦，让各个模块之间没有紧密的联系

现在的处理方法是 属性在更新的时候调用 mountComponent 方法

问题：mountComponent 更新的是什么？？？（现在）全部的页面 ->当前虚拟 DOM 对应的页面 DOM

在 vue 中，整个的更新都是按照组件为单位进行 **_判断_**，以节点为单位进行提交

- 如果代码中没有自定义组件，那么在比较算法的时候，我们会将全部的模板对应的虚拟 DOM 进行比较

- 如果代码中含有自定义组件，那么在比较算法的时候，就会判断更新的是哪一些组件中的属性，只会判断更新数据的组件，其他组件不会更新

复制的页面是有很多组件构成，每一个属性要更新的都要调用更新的方法？

**目标，如果修改了什么属性，就尽可能只更新这些属性对应的页面 DOM**

这样就一定不能将更新的代码写死

实际上就是事件模型（事件模型详情见 day02\demes\09-事件模型.html）

1. 有个 event 对象
2. on,off,emit 方法

实现事件模型，思考怎么用？

1. event 是一个全局对象
2. event.on('事件名'，处理函数)， 订阅事件
   1. 事件可以连续订阅
   2. 可以移除：event.off()
      1. 移除所有
      2. 移除某一个类型的事件
      3. 移除某一个类型的某一个处理函数
3. 写别的代码
4. event.emit('事件名'，参数)， 先前注册的事件处理函数就会依次调用

原因：

1. 描述发布订阅模式
2. 后面会使用到事件

发布订阅者模式（形式不局限于函数，形式可以是对象等）：

1. 中间的全局的容器，用来**存储**可以被触发的东西（函数，对象）
2. 需要有一个方法，可以往容器中**传入**东西（函数，对象）
3. 需要有一个方法，可以将容器中的东西取出来**使用**（函数使用，对象的方法调用）

Vue 模型

页面中的变更（diff）是一组件为单位

- 但是如果页面中有多个组件（多 watcher 的一种情况），第一次会有多个组件的 watcher 存入到全网 watcher 中
- 如果修改了局部的数据（例如其中一个组件的数据）
- 表示只会对该组件进行 diff 算法，也就是说只会重新 render 生成该组件的 VNode（不会重新生成抽象语法树）
- 只会访问该组件的 watcher
- 也就表示再次往全局存储的只有该组件的 watcher
- 页面更新的时候也就只需要更新一部分

**以下为对 src 文件里的改写**

## 改写 observe

缺陷：

- 无法处理数组
- 响应式无法在中间集成 watcher 处理
- 我们实现的 reactify 需要和实例紧紧的绑定在一起

## 引入 watcher

问题：

- 模型（图）
- 关于 this 指向问题

实现：
分成两步：

1. 只考虑修改后刷新（响应式）
2. 再考虑依赖收集（优化）

在 vue 中提供一个构造函数 Watcher
Watcher 会有一些方法

核心方法

- get() 用来进行**计算**或**执行**处理函数
- uptate()公共的外部方法，该方法会触发内部的 run 方法
- run() 运行，用来判断内部是使用异步运行还是同步运行等，这个方法最终会调用内部的 get()方法
- cleanupDep()，简单理解为清除队列

我们的页面渲染是上面哪一个方法执行的呢？？（get 方法）

我们的 watcher 实例有一个属性 vm,表示的就是当前的 vue 实例
